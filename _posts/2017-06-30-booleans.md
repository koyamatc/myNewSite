---
layout: post
title: Adding interactivity to HTML documents
date: 2017-06-19 00:00:00 +900
categories: post edx javascript
description:
  edx's course by W3C.
  Introductory course designed to understand 
  the basic concepts of JavaScript.  
---

-------
#### Boolean values and logical operators

##### Introduction

以前、JavaScriptのプログラムがどの様に判断を下せるのかについて話しました、
それは「もし条件が満たされたらこのことを行う、さもなければ、そちらを行う」というようにです、さらに少し概念を導入する必要があります。

まず、"真偽値(boolean value)" と "論理演算子"からです

##### Boolean values
真偽型は、2種類の値 真(true) と 偽(false) を持つ論理的エンティティを表します

キーワード true と false　を使う:
{% highlight javascript linenos %}
var b = true; 
 
var b = false;
{% endhighlight %}

真偽型の変数はクォーテーションマークで囲ってはいけません、それは文字列変数になってしまいます:
{% highlight javascript linenos%}
var b = 'true'; // b is not a boolean but a string
{% endhighlight %}

##### Undefined and null values

__Undefined__

undefined は　変数がまだ割り当てられていないときに返されます:
{% highlight javascript linenos %}
var foo;
> foo
undefined
 
> typeof foo;
'undefined'
 
>if (foo === undefined) {
    console.log('The variable foo has no value and is undefined');
}
'The variable foo has no value and is undefined'
{% endhighlight %}

上記の例は、変数が値を持っているかをどうテストするかを示しています（８行目は条件文を使用しています）

キーワード "undefined" は、JavaScript 言語の仕様であり、変数に未定義の値を割り当てられるということです:
{% highlight javascript linenos %}
> var foo = undefined; // equivalent to var foo; without giving any value
undefined
 
> foo;
undefined
 {% endhighlight%}

var foo; と var foo = undefined; は、同じですが、変数を宣言するときは最初のほうを推奨します(短くてコードを短縮できます）

まだ宣言されていない変数にアクセスしようとすると、参照エラー（ReferenceError）が生成されます。
しかし、 typeof演算子は "undefined"を返します。
{% highlight javascript linenos %}
> bar;
ReferenceError
 
> typeof bar;
'undefined'
{% endhighlight %}

##### Logical operators

論理演算子は以下のようなものがあります: 
<ul class="collection">
    <li class="collection-item">
        <em>&&(AND)</em>
        <p使用例 : if ((x  > 0) && (x < 10)) { 
                 console.log('x is strictly positive and less than 10'); 
             }</p>
    </li>
    <li class="collection-item">
        <em>||(OR)</em>
        <p>使用例 : if ((x  > 0) || (x == -5)) { 
                 console.log('x is positive or equal to -5'); 
             }</p>
    </li>
    <li class="collection-item">
        <em>!(NOT)</em>
        <p使用例 : if (!(x  > 0)) { 
                 console.log('x is not positive (x is less or equal to 0'); 
             }</p>
    </li>
    <li class="collection-item">
        <p>&&, || 演算子は2項, ! は単項 </p>
    </li>
</ul>
{% highlight javascript linenos %}
var b = !true; 
b; //false
 
var b = !!true;
b; //true
 
var b = "one"; 
!b;   false // implicit conversion of "one" to a boolean value
 
var b = "one"; // implicit conversion of "one" to a boolean value
!!b; //true
{% endhighlight %}
 論理演算子を含む式（上記例の８と１１行目）では、真偽型ではない値は、真偽値に変換されます。

 ##### Lazy evaluation or short-circuit evaluation:
論理式は左から右の順に評価されます。 JavaScript は　"short-circuit evaluation"として知られるメカニズムを使い明らかなケースにおいては、2番目、3番目、n番目の条件のテストを回避します：
<ul class="collection">
    <li class="collection-item">
    false && something (an expression)  is always false, and the part to the right of && operator is not tested.
    </li>
    <li class="collection-item">
    true || something (an expression) is evaluated to true, and the part to the right of the || operator is not tested.
    </li>
</ul>
例:
{% highlight javvascript linenos %}
var b = 5;
var c = 6;
 
if ((b === 5) || (b === 6))  { //the second part is never tested
    console.log('b is equal to 5 or equal to 6');
}
 
if ((b === 5) && (c === 6)) {  // second part is evaluated
    console.log('b  is equal to 5 and c is equal to 6');
}
 
if ((b === 15) && (c === 6)) {  // second part is never evaluated
    console.log('b  is equal to 5 and c is equal to 6');
} else {
    console.log('b not equal to 15 or c not equal to 6');
}
{% endhighlight %}

##### Implicit conversions of non boolean values in expressions

論理演算子が付いている、または、ステートメントの中にあるとき、
真偽型でない値は、真偽値に変換されます
<strong class="red-text">下記のすべての値は false と評価されます:</strong>
<ul class="collection">
    <li class="collection-item">false</li>
    <li class="collection-item">undefined</li>
    <li class="collection-item">null</li>
    <li class="collection-item">0</li>
    <li class="collection-item">NaN</li>
    <li class="collection-item">the empty string ''</li>
</ul>

<strong class="red-text">そのほかすべての値は true と評価されます!</strong>
{% highlight javascript linenos %}
var boo = 'hello' && 'world';
{% endhighlight %}
boo equals 'world' because 'hello' is a string value that is evaluated as true.
{% highlight javascript linenos %}
var boo2 = (0/0) || 43.2 ;
{% endhighlight %}
 boo2 equals 43.2 because the expression 0/0 equals NaN, which is evaluated as false.

__Question:__

このコードが実行された後の変数 myNumber の値は何ですか？ 
{% highlight javascript linenos %}
var myNumber = !1;
 
if(myNumber == null){
   myNumber = 3;
}
 
myNumber = myNumber || 2;
{% endhighlight %}

__説明:__ 1行目の後に、 myNumber は false。
3行目の if 文の中では false は null　とイコールではないので、値３は 変数 myNumber に割り当てられwません。
最後の行で、 myNumber は false と評価されます、 そして値２が変数 myNumber に与えられます。

##### Comparison Operators
<ul class="collection">
    <li class="collection-item">Equal ==</li>
    <li class="collection-item">Not equal !=</li>
    <li class="collection-item">Greater than ></li>
    <li class="collection-item">Greater than or equal >=</li>
    <li class="collection-item">Less than <</li>
    <li class="collection-item">Less than or equal to <=</li>
    <li class="collection-item">Strict equal ===</li>
    <li class="collection-item">Strict not equal !==</li>
</ul>

JavaScriptにおいて __==__ と __===__ の違いは何でしょう?

__Equal (==)__

オペランド（演算の対象）が型変換をすれば、まったく同じであるとき true を返します

__Strict equal (===)__

オペランドが型変換をしなくても全く同じであるとき true を返します

3重イコール演算子は型変換を決して行いませんから、オペランド両方が、同じオブジェクトを参照しているか、
または、値の型が同じで、値も同じである場合に true を返します。

Some examples :
{% highlight javascript linenos %}
1 == 1 ;
//true
 
1 == 2 ;
//false
 
/* Here, the interpreter will try to convert the string ‘1’
into a number before doing the comparison */
 
1 == '1';
//true :
 
 
//with strict equal, no conversion:
 
1 === 1;
//true
1 === '1';
//false
{% endhighlight %}

<p class="materialize-red-text">
内容によりますが、一般には　厳密なイコール（厳密な 否イコール）をつかうのがよい 
</p>
<p class="materialize-red-text">
初心者は: === または !== を比較には常に使いましょう
</p>

ここに、この件に関する興味ある記事があります

["Why you should use strict equal"](https://www.impressivewebs.com/why-use-triple-equals-javascipt/) (Impressive Webs, March 1st, 2012)

##### Specific case of NaN

JavaScript には特別な値があることを見てきました。
その一つが NaN: “Not-a-Number”. 

NaN は　このような特別な属性があります : 
{% highlight javascript linenos %}
NaN == NaN;
// false
 
NaN === NaN;
// false
{% endhighlight %}

 __Nan は何もないということです - 自分自身でさえないのです!__  しかし　NaN値をチェックする関数があります:  isNaN(expr) 

isNaN: 引数が NaN である場合のみ true を返し、それ以外では false を返します。
{% highlight javascript linenos %}
isNaN(NaN);
// true
 
isNaN(0/0);
// true
 
isNaN(12);
// false
 
isNaN('foo');
// true
{% endhighlight %}

"値 X が NaN であるかをテストする頼れる ECMAScript コードは、
X !== X 形式です。 結果は X が NaN　の時だけ true となります。 " ([isNan documentation](http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.4))を見てください。

##### A complete example with isNaN: 
{% highlight javascript linenos %}
var num =0/0;
 
if(isNaN(num)){
   num = 0;
}
//shortened version with the conditional operator
var num = isNaN(num) ? 0 : num
 
//version with logical operator (implicit conversion)
var num = num || 0;
 
/*
   <=> num = NaN || 0
 
   <=> num = false || 0
*/
 
num;
//returns 0 in this three cases
{% endhighlight %}
当然 0/0 も、たまには起こりますが、 NaN が発生する別のケースがあります、例えば:
<ul class="collection">
    <li class="collection-item">
    parseInt('foo');  NaNを返す   //parseInt は文字列を数値に変換しようとします    
    </li>
    <li class="collection-item">
    Math.sqrt(-1); NaN を返す     
    </li>
</ul>

-------

#### Conditional statements: if...then...else, switch
##### Conditional statements

__What are statements?__

JavaScript の　ソースコードは、ステートメント（文）の集まりです。
ステートメントにはいくつかの種類があります。
すでに見てきたステートメントの種類に、変数ステートメントがあります:
{% highlight javascript lineons %}
var myVar = 'hello ' + 'world';
{% endhighlight %}
式ステートメントも見ました:
{% highlight javascript linenos%}
3 + 4;
 
// more often like this
var x = (3 + 4);
var y = (5 + x);
{% endhighlight %}
ステートメントは、セミコロンで終わります、しかし、後で出てきますが、
セミコロンがない場合に、自動的に挿入されます(コードを読みとるための理由。W3Cでは、すべてのステートメントの終わりには、セミコロンを機械的につけることを強く推奨しています）。

ステートメントは通常、スクリプトの上から下へと順番に実行されます。
　しかし、この流れを変えることができます、その時使うものに、条件文や繰返し文があります。

__The block statement__

ブロック文は、単純な文であり、それは波括弧に挟まれた複数の分を一まとめにしたものです

Block statement:
{% highlight javascript linenos %}
{
    var i = 0;
    var result = false;
    console.log('i = ' + i);
}
{% endhighlight %}
ブロック文は、ほかの文で使われます、例えば、if 文 とか for 文でです。

__Conditional statements__

CodePen や devTool の console でいろいろ試してみてください

{% highlight javascript linenos %}
/*CONDITIONAL STATEMENTS*/
/*if statement*/

var num = 10;
if (num == 10) {
    num = 20;
}

console.log('if statement,\n num>> ' + num);

/*if-else statement*/

var num = 10;
if (num > 10) {
    num = 20;
} else {
    num = 0;
}

console.log('if-else statement,\n num>> ' +num);

/*
Question 1 
how to replace this code by an expression including one operator?
*/
var max; 
var min;
// Try to uncomment that and // see the difference!
// var min=1;
if (min){
    max = min + 10;
} else {
    max = 10;
}
console.log('question1, \n max>> ' + max);
//Answer is at the end of the document


/*switch statement*/

//this example is equivalent to the previous if-else example
var num = 10;
switch(num){
  case(num>10): num=20;
    break;
  default: num = 0;
}
console.log('switch1,\n num> ' + num);

//switch statement behaviour when break keyword is missing
//comment and uncomment cloudColor variable to see the different results

var gear = '';
//var cloudColor;
//var cloudColor = 'green';
var cloudColor = 'black';
switch(cloudColor) {
    case 'green': gear += 'spacesuit';
        break;
    case 'black': gear += 'boots, ';
    case 'grey': gear += 'umbrella, ';
    case 'white': gear += 'jacket, ';
    default: gear += 'watch';
}

console.log('switch2,\n gear >> ' + gear);

//The above example with break; 

var gear = '';
//var cloudColor;
//var cloudColor = 'green';
var cloudColor = 'black';
switch(cloudColor) {
    case 'green': 
      gear += 'spacesuit';
      break;
    case 'black': 
      gear += 'boots, ';
      break;
    case 'grey': 
      gear += 'umbrella, ';
      break;
    case 'white': 
      gear += 'jacket, ';
      break;
    default: 
      gear += 'watch';
}

console.log('swtich3,\n gear >> ' + gear);



/*
Question 1 
how to replace this code by an expression including one operator?
var max;
var min;
if (min){
    max = min + 10;
} else {
    max = 10;
}
*/

//Answer
var max;
var min;
max = (min)? min+10 : 10;
//console.log('question 1,\n max >> ' + max);
{% endhighlight %}

(Please look, edit and try whatever you want. There are parts that are commented - please remove comments and try to understand the results).

<p class="center">
条件文は一塊のコードを実行するために使われます 
</p>
<p class="center">
条件が true と評価された場合のみ
</p>

##### The if statement

Syntax:
{% highlight javascript linenos %}
if ( Expression ) Statement else Statement

if ( Expression ) Statement
{% endhighlight %}

__The expression may include:__

<ul class="collection">
    <li class="collection-item">
    論理演算子 ( ! && || )    
    </li>
    <li class="collection-item">
    比較演算子 ( ==, ===, >, >=, <, <= )    
    </li>
    <li class="collection-item">
    値 や 式　で、それらは真偽値に変換される    
    </li>
</ul>

Example: if-statement
{% highlight javascript linenos %}
var num = 10;
 
if (num === 10) {
    num = 20;
}
 
// num equals 20
{% endhighlight %}

Example: if-else statement
{% highlight javascript linenos %}
var num = 10;
 
if (num > 10) {
    num = 20;
} else {
    num = 0;
}
 
// num equals 0
{% endhighlight %}

__Reminder:__

下記の値は false と評価される:
<ul class="collection">
    <li class="collection-item">false</li>
    <li class="collection-item">undefined</li>
    <li class="collection-item">null</li>
    <li class="collection-item">0</li>
    <li class="collection-item">NaN</li>
    <li class="collection-item">""(empty string)</li>
</ul>
<p class="materialize-red-text">
すべてのオブジェクトを含め、すべての値は、条件文のなかでは true と評価されます
</p>

__The if-then-else ternary operator__

三項演算子は if...then...else　の短縮バージョンです。

コード例:
{% highlight javascript linenos %}
var max;
var min = 2;
 
if (min < 10) {
    max = min + 10;
} else {
    max = min;
}
{% endhighlight %}
__Explanation:__ この "if-then-else" 文を 三項演算子で置き換えられます、 "?" and ":"文法を使います
{% highlight javascript linenos %}
var max;
var min;
max = (min < 10)? min+10 : min;
{% endhighlight %}

行 3 は if (min < 10) then max = min+10, else max = min　と読めます。 "then"部分は "?" の後ろで "else" 部分は　":" の後ろです。

この短縮形は "then" と　"else　部分が、とても分かりやすい命令を含む、
とても単純な文である以外には推奨されません。通常、初心者には大変読みづらい文法です。

__Curly braces__

if-then-else 文で波括弧を使わなければならないのか? 
波括弧の無い例がウェブ上にあります。: どういう意味でしょう?

同じコードの2つのバージョンです。

Version 1: no curly braces
{% highlight javascript linenos %}
if (a > 2)
    result = 'a is bigger than 2';
else
    result = 'a is not bigger than 2';
{% endhighlight %}
Version 2: with curly braces for delimiting the "then" and "else" blocks
{% highlight javascript linenos %}
if (a > 2) {
    result = 'a is bigger than 2';
} else {
    result = 'a is not bigger than 2';
}
{% endhighlight %}

バージョン 1 と 2 は、同等です。 しかし、バージョン 1 が正解です: 波括弧は付けなくていいです
もし "then" または "else" ブロックが 1文 (1行のコード)だけの場合は。

しかし、バージョン 2 は、より簡潔で読みやすく、特に、保守性に優れています 
(なぜならエンターキーを押すだけで1行追加できます。
さらに、"1行ルール" を破り波括弧を追加することを気にせず、もっと行を追加できます).

それゆえに、if-statements には、波括弧を常に使うことを勧めます。 

当然、このような1行 if-statements は :
{% highlight javascript linenos %}
if (true) doSomething();
{% endhighlight %}
実際、速く書けます、しかし、後で文を追加する予定があるならば、その時はより時間がかかると予想されます

__Conclusion:__ always use curly braces!

##### The switch statement

if と else を連続して使うのを避けるために、switch 文を使うことができます。 

switch 文の文法は:
{% highlight javascript linenos %}
switch (expression) {
    case value1:
        statement
        break;       // break を省けるのは、
                     // その次のテストケースを実行させる場合です
                     // ほとんどの場合 break を付けます;
                     // "case"の最後のところに
 
    case value2:
        statement
        break;
 
    case value3:
        statement
        break;
 
    default:         // if no case tested true
        statement
        break;
}
{% endhighlight %}
もし式の値がケースのひとつとイコールである（評価に使われる演算子は===です）、
この case ブロックの次のすべての文はキーワード break が見つかるまで順番に実行されます。

Example 1: a common switch/case/default example.
{% highlight javascript linenos %}
var gear = '';
 
switch (cloudColor) {
    case 'green':
        gear = 'spacesuit';
        break;
 
    case 'black':
        gear = 'boots';
        break;
 
    case 'grey':
        gear = 'umbrella';
        break;
 
    case 'white':
        gear = 'jacket';
        break;
 
    default:
        gear = 'watch';
        break; // useless if in the last case
} // end of the switch statement
{% endhighlight %} 

この例では、もし雲が灰色の場合、使うものは傘になります。もし雲が白なら、上着を着ます、
もし黒なら、裸でブーツだけ（！）、そして緑なら、宇宙服。
雲の色がこの中になかったときは、腕時計をつけるだけ。
異なるケースの最後に break キーワードがあることは、100% 排他的に選択が行われ、1つのケースだけが実行されます。

 Example 2: a switch without "breaks" at the end of each case.
{% highlight javascript linenos %}
var gear = '';
 
switch (cloudColor) {
    case 'green':
        gear += 'spacesuit';
        break;
 
    case 'black':
        gear += 'boots, ';
 
    case 'grey':
        gear += 'umbrella, ';
 
    case 'white':
        gear += 'jacket, ';
 
    default:
        gear += 'watch';
} // end of the switch statement
{% endhighlight %} 
__Explanation:__ もし雲が黒いなら、使うものは、'ブーツ, 傘, 上着, 腕時計'となります。
もし雲が緑なら、使うものは 宇宙服 (break キーワードがない場合, ほかのケースはテストされません)。
もし色がリストの中に無ければ、使うものは腕時計だけです(default case)。

このセクションの最後に完全な例を: three ways to do condition statements (to run it: click on the "edit on codepen" label and once in codepen, open the devtool console to see the outputs of this program):

{% highlight javascript linenos %}
/*CONDITIONAL STATEMENTS*/
/*3 examples which are equivalent*/

//try to change foo value 
var foo=1;
//var foo=2; 
//var foo=1000;
//var foo=0;
//var foo='1';

var bar1,bar2,bar3;

//example 1 
if(foo===1){
  bar1='one';
}
else if(foo===2){
  bar1='two';
}
else{
  bar1='something';
}

//example 2
bar2 = (foo===1)?'one':(foo===2)?'two':'something';

//example 3
switch(foo){
  case 1 :
    bar3='one';
    break;
  case 2 : 
    bar3 ='two';
    break;
  default:
    bar3 ='something';
}

//now we print results :

console.log('example1,\n bar1 >> ' + bar1);
console.log('example2,\n bar2 >> ' + bar2);
console.log('example3,\n bar3 >> ' + bar3);

{% endhighlight %}

-----------

#### Loop statements
##### Loops
ループは、条件が満たされている間、数回同じコードブロックを実行するために使います。

ループで困ったときには、オンライン・ツールの slowmoJS が、役立つでしょう: 
その中の例をコピペして、ステップバイステップで動かし、プログラムがどの様に実行されるかを見てみましょう。

__The while statement__

while 文は、 指定された条件が満たされている間(True)、繰返しコードブロックが実行されます。

Syntax:
{% highlight javascript linenos %}
while ( condition ) statement
{% endhighlight %}
条件は式です、 そして、文は、ブロック文でもよいです。

while 文の例:
{% highlight javascript linenos %}
var i = 1, j = 1;
 
while ( i < 4 ) {
    j += i;
    i += 1; 
}
...
{% endhighlight %}

while 内のブロック (行 4 と 5) は、3回実行されます:
<ul class="collection">
    <li class="collection-item">
    行 1 は、i を 値 1 で初期化します    
    </li>
    <li class="collection-item">
    行 3 で、while 文に入ります。i の値は厳密に比較して 4 より小さいですか？    
    </li>
    <li class="collection-item">
はい, 変数 i は 1 に等しいです、 while 内の文に入ります
    </li>
    <li class="collection-item">
        Run 1:
        <ul class="collection">
            <li class="collection-item">
            行 4 を実行: j += i; (equivalent to j = j + i). 1 行目で j は 1 に設定されています, そして j は今 2です。
            </li>
            <li class="collection-item">
            行 5 を実行すると i は 1 増加します。 変数 i は 2 となります。            
            </li>
            <li class="collection-item">
            3 行目の while に戻ります。 i < 4? はい, 行 3 と 4 を再び実行します
            </li>
        </ul>
    </li>
    <li class="collection-item">
        Run 2:
        <ul class="collection">
            <li class="collection-item">
            今、行 5 の最後にいます、 j は "古い j 値" + "新しい i の値"、つまり j = 2 + 2 = 4, i は１増えて今 ３ です。
            </li>
            <li class="collection-item">
            行 3 に戻ります. i < 4? はい, 行 3 と 4 を再び実行します。
            </li>
        </ul>
    </li>
    <li class="collection-item">
        Run 3:
        <ul class="collection">
            <li class="collection-item">
            ５行目の最後にいます, j は"古い j の値" + "新しい i の値", つまり j = 4 + 3 = 7, i は増加し 4　となります。
            </li>
            <li class="collection-item">
            行３の while に戻ります。 i < 4? いいえ! i の値は 4　です、 4より小さくありません。
            i = 4 で j = 7　で行７よりプログラムは実行を続けます。
            </li>
        </ul>
    </li>
</ul>

Of course, if the condition never evaluates to false, the block will be executed infinitely until the machine crashes... a test like while (i > 0) { .....} will never stop and will eat all the CPU.

Try this example now with slowmoJS !

__The do-while statement__

The do-while statement is very similar to the while statement, but its syntax is different:
{% highlight javascript linenos %}
do statement while ( condition )
{% endhighlight %}

Typical example:
{% highlight javascript linenos %}
var i = 0;
 
do {
    console.log('i = ' + i);
    i++;
} while(i < 20);
{% endhighlight %} 

console.log('Value of i after the do-while statement: ' + i);

The do-while statement executes the content of the loop once before checking the condition of the while, whereas a while statement will check the condition first before executing the content.

A do-while is used for a block of code that must be executed at least once.These situations tend to be relatively rare, thus the simple while-statement is more commonly used. 

If you want to "see" the difference, [look at the "do-while" statement with slowmoJS](http://toolness.github.io/slowmo-js/?code=var%20condition%3D%20false%3B%0Avar%20foo%20%3D%200%3B%0Ado%7B%0A%20foo%2B%2B%3B%0A%7D%20while(condition%20%3D%3D%20true)%3B%0A%0Afoo%3B&filterrange=80-80) and [the "while" statement slowmoJS](http://toolness.github.io/slowmo-js/?code=var%20condition%3D%20false%3B%0Avar%20foo%20%3D%200%3B%0Awhile(condition%20%3D%3D%20true)%3B%20%7B%0Afoo%2B%2B%0A%7D%0A%0Afoo%3B&filterrange=68-68). 

__The for statement__

This statement adds some things to the while and do-while statements: an initialization expression and an incrementing expression.

Its syntax is:
{% highlight javascript linenos %}
for (initialization; condition; incrementation) statement
{% endhighlight %}

The three expressions within the parentheses are optional. If the condition is omitted, it is replaced by true (infinite loop).

Typical example (counting from 0 to 10):
{% highlight javascript linenos %}
for (var i = 0; i <= 10; i++) {
   console.log('i = ' + i);
}
{% endhighlight %}

We can have more than one instruction in the "initialization part", and more than one instruction in the "incrementation part". Here is another example:

{% highlight javascript linenos %}
for (var i = 1, j = 1; i <= 10; i++, j+=2) {
    console.log('i = ' + i + ' j = ' + j);
}
{% endhighlight %}

In this example, two variables are defined and assigned within the initialization expression. Before each execution of the block statement, the condition is checked; here we need i <=10. After each execution of the block statement, the incrementation expression is executed to increment the variables i by 1 and j by 2.

Open the devtool console of your browser and copy and paste the above code, or [look at the slowmoJS execution](http://toolness.github.io/slowmo-js/?code=for%20(var%20i%20%3D%201%2C%20j%20%3D%201%3B%20i%20%3C%3D%2010%3B%20i%2B%2B%2C%20j%2B%3D2)%20%7B%0A%20%20%20%20console.log(%27i%20%3D%20%27%20%2B%20i%20%2B%20%27%20j%20%3D%20%27%20%2B%20j)%3B%0A%7D&filterrange=0-89).

__The for-in statement__

The for-in statement is used to iterate through an object (or through an array, which is also an object). 

Its syntax is:
{% highlight javascript linenos %}
for ( variable in expression ) statement
{% endhighlight %}
Typical example:
{% highlight javascript linenos %}
var michel = {              // michel is an object
    familyName:'Buffa',     // familyName, givenName, age
                            // are its properties
    givenName: 'Michel',
    age: 51
}
 
for(var property in michel) {   // the for-in will
                                // enumerate properties
    console.log(property);      // will print "familyName",
                                // "givenName",
                                // "age"
    console.log(michel[property]);  // michel['givenName'] same 
                                    // as michel.givenName
}
{% endhighlight %}

Before each execution of the block statement, the variable named "property" is assigned with the name of one of the properties (the keys) of the object.

We will see further examples of this statement in module 4, which is devoted to the study of JavaScript objects.

##### [ADVANCED] Other statements

__The continue statement__

The continue statement is used to stop the execution of a block and start the next iteration of the loop. The difference from the "break" statement is that the loop continues.

Syntax:

{% highlight javascript linenos %}
continue [label]
{% endhighlight %}
The label is optional.

Typical example:
{% highlight javascript linenos %}
for(var i = 1, k = 0; i < 5; i++) {
    if (i === 3) {
        continue;
    }
 
    k += 2*i;
    console.log('k += ' + (2*i));
}
console.log('Final k value:' + k)
{% endhighlight %}
Copy and paste this example in your devtool console, but first, try to guess what the value of k will be!

Hint: lines 2-4 mean that line 6 will never be executed for i = 3. That means that i*2 will only be added to k for i = 1, 2 and 4...

__The break statement__

The break statement is used to stop an iteration, a switch or a labelled statement.

Syntax:

{% highlight javascript linenos %}
break [label]
{% endhighlight %}
Typical example:
{% highlight javascript linenos %}
var tab = ['michel', 'john', 'donald', 'paul']; // johh at index = 1
 
function isNameInTheArray(name, theArray) {
    console.log("Number of elements in the array : " + theArray.length);
    for(var i=0; i < theArray.length; i++) {
        console.log('comparing with element in the array at pos ' + i);
 
        if(theArray[i] === name) {
           console.log('the name ' + name +
                       ' is in the array at pos: ' + i);
           break;
        } else {
           console.log(name + ' is not at pos ' + i);
        }
    }
}
 
// Execute the function
isNameInTheArray('john', tab);
{% endhighlight %}

Copy and paste in the devtool console. You'll see that the function that compares each element in the array passed as the second parameter with the name 'john', will stop looping after 'john' has been found at index = 1.

__Detailed explanations:__

<ul class="collection">
    <li class="collection-item">
    Line 20 executes the function    
    </li>
    <li class="collection-item">
    Line 6: The for statement loops on all existing indexes in the tab, from 0 to tab.length    
    </li>
    <li class="collection-item">
    Line 9: if the condition is true, we enter the block and execute lines 10-12    
    </li>
    <li class="collection-item">
    The break statement at line 12 will exit from the loop, it "breaks" the loop.    
    </li>
    <li class="collection-item">
    The different console.log(...) will never display the message "comparing with elements..." with indexes greater than 1: the loop exists when 'john' is found at index 1 (i equal to 1).   
    </li>
</ul>

------------

#### Functions and callbacks
##### Two ways to declare a function

__1 - Standard function declaration__

We've already seen that functions can be declared using this syntax:
{% highlight javascript linenos %}
function functionName(parameters) {
// code to be executed
}
{% endhighlight %}
A function declared this way can be called like this:
{% highlight javascript linenos %}
functionName(parameters);
{% endhighlight %}
Notice that we do not add a semicolon at the end of a function declaration. Semicolons are used to separate executable JavaScript statements, and a function declaration is not an executable statement.

Here is an example:
{% highlight javascript linenos %}
function sum(a, b) {
  // this function returns a result
  return (a + b);
}

function displayInPage(message, value) {
  // this function does not return anything
  document.body.innerHTML += message + value + "<br>";
}

var result = sum(3, 4);
displayInPage("Result: ", result);

// we could have written this
displayInPage("Result: ", sum(10, 15));
{% endhighlight %}

In the above example, the sum function returns a value, and the displayInPage function does not return anything.

__2 - Use a function expression__

A JavaScript function can also be defined using an expression that can be stored in a variable. Then, the variable can be used as a function:

Here is a typical example:
{% highlight javascript linenos %}
var sum = function(a, b) {
  return (a + b);
};

var displayInPage = function(message, value) {
  // this function does not return anything
  document.body.innerHTML += message + value + "<br>";
};

var result = sum(3, 4);
displayInPage("Result: ", result);

// we could have written this
displayInPage("Result: ", sum(10, 15));
{% endhighlight %}

Notice how the sum and displayInPage functions have been declared. We used a variable to store the function expression, then we can call the functions using the variable name. And we added a semicolon at the end, since we executed a JavaScript instruction, giving a value to a variable.

The "function expression" is an "anonymous function", a function without a name, that represents a value that can be assigned to a variable. Then, the variable can be used to execute the function.

We say that functions are "first class objects" which can be manipulated like any other object/value in JavaScript.

This means that functions can also be used as parameters to other functions. In this case they are called "callbacks".

##### Callbacks

Indeed, as functions are first-class objects, we can pass a function as an argument, as a parameter to another function and later execute that passed-in function or even return it to be executed later. When we do this, we talk about callback functions in JavaScript: a function passed to another function, and executed inside the function we called.

All the examples of event listeners that you've seen used callback functions. Here is another one that registers mouse click listeners on the window object (the window objects represent the whole HTML document):

{% highlight javascript linenos %}
// Add a click event listener on the whole document
// the processClick function is a callback:
// a function called by the browser when a click event
// is detected
window.addEventListener('click', processClick);

function processClick(event) {
  document.body.innerHTML += "Button clicked<br>";
}

// We could have written this, with the body of the callback as an argument of the addEventListener function
window.addEventListener('click', function(evt) {
  document.body.innerHTML += "Button clicked version 2<br>";
});
{% endhighlight %}

In this case, the processClick function is passed as a parameter to the addEventListener method/function.

Callback functions are derived from a programming paradigm known as functional programming. They are very, very common in JavaScript. We'll use them a lot in the next section of the course, called "Handling events".

-----------

### handling events
#### Introduction
ウェブ　アプリケーションをインターラクティヴにするには、例えば、
CSSの疑似クラス :hover を使ってもできます
<div class="row">
    <div class="col s12 m6">
{% highlight javascript linenos %}
button:hover {
  color:red;
  border:2px solid;
}
{% endhighlight %}
    </div>
    <div class="col s12 m6">
<style type="text/css">
#hoverButton:hover {
  color:red;
  border:2px solid;
}
#box01 {
    border: 3px solid #000;
    height: 200px;
}
</style>
    <button id="hoverButton" class="btn">Put the mouse cursor over me</button>
    </div>

</div>

しかし、マウスボタンを使ってボタンが押されたときに特定のアクションを起こさせるには、
マウス・ポインターの位置(x, y)が、ボタンのシステム座標内にあるか計算します、
また、もっと複雑な作業を実行するには、JavaScript を通してのみ行うことができます。

JavaScript で, ボタンのクリック、マウスの移動、ウィンドウのリサイズ、その他の多くの相互作用は
"イベント(event)"と呼ばれつものを生成します。
 イベントが生成されるタイミングと順番は、前もって予言できません。
 イベント処理は、非同期であるといえます。
 ウェブ　ブラウザはイベントの発生を検知し、そして、JavaScript コードへ受け渡します。
 これをするために、イベント・リスナとしての関数を登録し、
 特定のイベントのためのハンドラまたはコールバックを呼び出します
 
イベントが発生するたびに、 ブラウザは、そのイベントをイベント・キュウーに入れます

次に、ブラウザはイベント・リスナのリストを見て、聞いているイベントタイプに対応するリスナを呼び出します

#### Adding and removing event listeners
##### Event listeners: a typical example

イベント・リスナの登録方法の一つです。ボックス内でのクリック・イベントを聞いています。
ウェブ・ドキュメント上でクリックされると、そのイベント・ハンドラが処理を行います。
<div class="row">
    <div class="col s12 m6">
{% highlight javascript linenos %}
<script>
  addEventListener('click', function(evt) {
       document.body.innerHTML += "Button clicked!";
    });
</script>
{% endhighlight %}
    </div>
    <div id="box01" class="col s12 m6">
        <p>Click anywhere on this box</p>
    </div>
Try it below by clicking anywhere on the document:
<script>
  addEventListener('click', function(evt) {
      document.getElementById("box01").innerHTML += 'Button clicked!<br>';
  });
</script>
</div>

addEventListener 関数は、与えられたイベント・タイプが発生したときに、
呼び出される関数を登録する方法の一つです。
{% highlight javascript linenos %}
addEventListener(type_of_elem, __callback_function__)
{% endhighlight %}

To do >>>
例では, イベント・タイプは 'click'で、コールバック関数が the part in bold:

{% highlight javascript linenos %}
function(evt) {
   console.log("Button clicked!");
}t
{% endhighlight %}

コールバック関数が小さい（数行のコードの）時は、addEventListner関数の第二引数として本体に入れてしまうのが実践的です。

言い換えれば、これは:

{% highlight javascript linenos %}
<script>
addEventListener('click', function(evt) {
    document.body.innerHTML += 'Button clicked!';
});
</script>
{% endhighlight %}
クリックが発生したときに呼ばれる関数の本体は、addEventListnerの引数の外側にあり、
第二引数の名前を使って呼び出します。

{% highlight javascript linenos %}
<script>
addEventListener('click', processClick);
function processClick(evt) {
    console.log("Button clicked!");
}
</script>
{% endhighlight%}

##### Adding an event listener to specific HTML elements

ドキュメント全体でイベントを聞くのではなく、特定の DOM 要素に対して聞くことができます。

特定のボタンのクリック・イベントを聞く方法です
<div class="row">
    <div class="col s12 m8">
    {% highlight javascript linenos %}
<script>
    var b = document.querySelector("#myButton");
    b.addEventListener('click', function(evt) {
      alert("Button clicked");
    });
</script>    
    {% endhighlight %}
    </div>
    <div class="col s12 m4">
        <button id="myButton" class="btn">Click me!</button>
    </div>
 <script>
    var b = document.querySelector("#myButton");
    b.addEventListener('click', function(evt) {
      alert("Button clicked");
    });
</script>    
</div>

この例では、直接 addEventListner メソッドを使う代わりに、
DOM オブジェクト(button) に対してメソッドを使っています。
<ul class="collection">
    <li class="collection-item">
    1. 検知したいイベントを起動する HTML 要素への参照を取得する。
    これは, DOM APIを使って行われる。
    この例では: var b = document.querySelector("#myButton");
    </li>
    <li class="collection-item">
    2. このオブジェクト上で、addEventListener メソッドを呼びだす。
    この例では: b.addEventListener('click', callback)
    </li>
</ul>

どの DOM オブジェクトにも addEventListener メソッドがあります。
JavaScript で、HTML要素への参照を取得しさえすれば、
その要素のイベントを聞くことが始められる。

__An alternative method for adding an event listener to an HTML element: use an "on" attribute (ex: onclick = "....")__

b.addEventListener('click', callback)を使う代わりに、onclick='doSomething();' 属性を
直接 その要素の HTML タグに書くこともできます:

<div class="row">
    <div class="col s12 m8">
    {% highlight javascript linenos %}
<button id="myButton2" class="btn" onclick="processClick(event);">Click me!</button>
<script>
   function processClick(evt) {
      alert("Button clicked");
   };
</script>
    {% endhighlight %}
    </div>
    <div class="col s12 m8">
        <button id="myButton2" class="btn" onclick="processClick(event);">Click me!</button>
    </div>
    <script>
        function processClick(evt) {
          alert("Button clicked");
        };
</script>     
</div>

この文法は:
{% highlight javascript linenos %}
<button id="myButton" onclick="processClick(event);">Click me!</button>
{% endhighlight %}
... ok ですが、このボタンに対するクリック・イベントを聞くイベント・リスナが たった一つだけのときにはです。
なぜなら、onClick 属性は要素ごとに一つだけしか設置できないからです。

b.addEventListener('click', callback) 文法を使うことは, 
一つ以上のイベント・リスナを登録できるということです。
こんなことはめったに必要ないでしょうから、どちらの文法を使ってもいいでしょう。

大規模なプロジェクトの時には覚えておいてください、
HTML, CSS, JavaScript コードは、ファイルを分けるほうがより良いです。
この場合、すべてのイベント・リスナ定義を分割したJavaScriptファイルに置くことを推奨します。
"on" 属性文法への参照を addEventListner 文法を使います。

##### Removing event listeners
ボタンをクリックしたとき、processClick(evt) コールバック関数を実行します、
そして、その中で前もって登録していたリスナを取り除きます。
その結果: ボタンをクリックしても、何も起こりません。
<div class="row">
    <div class="col s12 m8">
    {% highlight javascript linenos %}
<button id="myButton">Click me, this will work only once!</button>
  <p></p>
  <script>
    var b = document.querySelector("#myButton");
    b.addEventListener('click', processClick);
    
    function processClick(evt) {
     alert("Button clicked, event listener removed, try to click on the button again: nothing will happen anymore!"); 
      b.removeEventListener('click', processClick);
    }
  </script>     
    {% endhighlight %}
    </div>
    <div class="col s12 m8">
        <button id="myButton3"> class="btn" Click me, this will work only once!</button>
    </div>
      <script>
    var b = document.querySelector("#myButton3");
    b.addEventListener('click', processClick);
    
    function processClick(evt) {
     alert("Button clicked, event listener removed, try to click on the button again: nothing will happen anymore!"); 
      b.removeEventListener('click', processClick);
    }
  </script>
</div>

注：イベント・リスナを取り除くためには、名前付き関数で追加しておく必要があります、
そうすることで、addEventListener と removeEventListener 両方へ受け渡すことができます

-------------

#### Event Object

##### The event object is the only parameter passed to event listeners
Typical example:
{% highlight javascript linenos %}
function processClick(evt) {
    alert("Button clicked!");
}
{% endhighlight %}

Each event listener has a single parameter that is  a "DOM event object". It has various properties and methods that can be very useful.

For example, with a 'keyup', 'keydown' or 'keypress' event, the event object contains the code of the key that has been pressed/released, with a 'mousemove' listener we can get the relative position of the mouse in the DOM element that has generated the event, etc.

The event object contains some important properties and methods that are common to all types of events:
<ul class="collection">
    <li class="collection-item">evt.type: the name of the event</li>
    <li class="collection-item">
    evt.target: for example, is the HTML element that has fired the event. In our previous examples with the click listeners on a button, evt.target in the event listener is the button itself.
    </li>
    <li class="collection-item">
    evt.stopPropagation(): will not propagate the event to all other elements that listen to it. If several elements are registered for a click event - for example, you have a click listener on a button and on the window (the whole page). If you click on the button, and if in its click event listener you call evt.stopPropagation(); then the click event listener on the window object will never be called.
    </li>
    <li class="collection-item">
    evt.preventDefault(): the default browser behavior will not be executed. For example, in a 'contextmenu' event listener attached to an object, if you call evt.preventDefault(), instead of having the right click default context menu of your browser displayed, you'll be able to display your own context menu, like in this example.
    </li>
</ul>

It also contains properties that are associated with the type of the event, for example:
<ul class="collectio">
    <li class="collection-item">
    evt.button: the mouse button that has been used in the case of a mouse event listener
    </li>
    <li class="collection-item">
    evt.keyCode: the code of the key that has been used
    </li>
    <li class="collection-item">
    evt.pageX: coordinate of the mouse relative to the page
    </li>
    <li class="collection-item">
    etc,
    </li>
</ul>

In the subsequent sections of this course we will look at the most common types of events in detail.

__Reference table__

The most useful common properties are:
<table class="bordered">
    <tr>
        <th>type</th>
        <td>Returns the name of the event.</td>
    </tr>
    <tr>
        <th>target</th>
        <td>Returns the element that triggered the event.</td>
    </tr>
</table>

The most useful common methods are:

<table class="bordered">
    <tr>
        <th>preventDefault()</th>
        <td>
        Cancels the event if it is "cancelable", meaning that the default action that belongs to the event will not occur. It is useful for cancelling the default browser behavior. For example: if you want to create a context menu that pops up with a right click, you must prevent the default behavior of the browser that will pop up its default context menu.    
        </td>
    </tr>
    <tr>
        <th>stopPropagation()</th>
        <td>Prevents further propagation of an event during event flow.</td>
    </tr>
</table>

-------

#### Page lifecycle events
These events detect when the page is loaded and when the DOM is ready.

##### Events related to the page lifecycle

There are many other events related to the page life cycle. The most useful ones for an introduction course are shown below:

<table class="bordered">
    <tr>
        <th>load</th>
        <td>
        This event occurs when an object has loaded (including all its resources: images, etc.). This event is very useful when you want to run JS code and be sure that the DOM is ready (in other words, be sure that a document.getElementById(...) or document.querySelector(...) will not raise an error because the document has not been loaded and elements you are looking for are not ready).
        </td>
    </tr>
    <tr>
        <th>resize</th>
        <td>
        The event occurs when the document view is resized. Usually, we get the new size of the window inside the event listener using var w = window.innerWidth; and
        var h = window.innerHeight;
        </td>
    </tr>
    <tr>
        <th>scroll</th>
        <td>
        The event occurs when an element's scrollbar is being scrolled. Usually in the scroll event listener we use things such as:
  var max = document.body.scrollHeight - innerHeight;
 var percent = (pageYOffset / max);
...to know the percentage of the scroll in the page.
        </td>
    </tr>
</table>

__Page event properties__

There are no particular properties that need to be mentioned here. Usually, the load event listener corresponds to a JavaScript function that can be seen as "the main" function of your Web application. It is a best practice to start everything after the page has been completely loaded. In the resize listener, you get the new size of the window, or the new size of some HTML elements in the page (as they might have been resized too when the window was resized), and then you do something (redraw a graphic in an HTML canvas that takes into account the new canvas size, for example).

Example 1: wait until the page is loaded (when the DOM is ready) before doing something

This first variant that uses <body onload="init();">