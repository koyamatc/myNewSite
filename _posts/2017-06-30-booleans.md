---
layout: post
title: Adding interactivity to HTML documents
date: 2017-06-19 00:00:00 +900
categories: post edx javascript
description:
  edx's course by W3C.
  Introductory course designed to understand 
  the basic concepts of JavaScript.  
---

-------
#### Boolean values and logical operators

##### Introduction

Before talking about how your JavaScript program can make decisions, such as "if this condition is fulfilled then I'll do this, otherwise I'll do that...", we need to define a few more concepts.

We will start with "boolean values" and "logical operators".

##### Boolean values

The boolean type represents a logical entity having two values: true and false.

Use of the keywords true and false:
{% highlight javascript linenos %}
var b = true; 
 
var b = false;
{% endhighlight %}

A boolean variable should not be enclosed in quotation marks, otherwise it becomes a string variable:
{% highlight javascript linenos%}
var b = 'true'; // b is not a boolean but a string
{% endhighlight %}

##### Undefined and null values

__Undefined__

undefined is returned when a variable has not been assigned:
{% highlight javascript linenos %}
var foo;
> foo
undefined
 
> typeof foo;
'undefined'
 
>if (foo === undefined) {
    console.log('The variable foo has no value and is undefined');
}
'The variable foo has no value and is undefined'
{% endhighlight %}

The above example shows how we can test whether a variable has a value (line 8 uses a conditional statement).

The keyword "undefined" is part of the JavaScript language, so you can assign the undefined value to a variable:
{% highlight javascript linenos %}
> var foo = undefined; // equivalent to var foo; without giving any value
undefined
 
> foo;
undefined
 {% endhighlight%}

var foo; and var foo = undefined; are equivalent but we recommend that you use the first version to declare the variable (it is shorter, and that reduces the code).

If you try to access a variable that has not been declared before, a ReferenceError will be raised. But the typeof operator will return "undefined":
{% highlight javascript linenos %}
> bar;
ReferenceError
 
> typeof bar;
'undefined'
{% endhighlight %}

##### Logical operators

The logical operators are as follows: 
<ul class="collection">
    <li class="collection-item">
        <em>&&(AND)</em>
        <p>usage example : if ((x  > 0) && (x < 10)) { 
                 console.log('x is strictly positive and less than 10'); 
             }</p>
    </li>
    <li class="collection-item">
        <em>||(OR)</em>
        <p>usage  example : if ((x  > 0) || (x == -5)) { 
                 console.log('x is positive or equal to -5'); 
             }</p>
    </li>
    <li class="collection-item">
        <em>!(NOT)</em>
        <p>usage example : if (!(x  > 0)) { 
                 console.log('x is not positive (x is less or equal to 0'); 
             }</p>
    </li>
    <li class="collection-item">
        <p>&&, || operators are binary, ! is unary. </p>
    </li>
</ul>
{% highlight javascript linenos %}
var b = !true; 
b; //false
 
var b = !!true;
b; //true
 
var b = "one"; 
!b;   false // implicit conversion of "one" to a boolean value
 
var b = "one"; // implicit conversion of "one" to a boolean value
!!b; //true
{% endhighlight %}
 In an expression with logical operators, as shown in lines 8 and 11 of the previous example, non-boolean values are implicitly converted to boolean.

 ##### Lazy evaluation or short-circuit evaluation:
Logical expressions are evaluated from left to right. JavaScript uses a mechanism known as "short-circuit evaluation" to prevent the second, third, and nth conditions from being tested in certain cases: 

<ul class="collection">
    <li class="collection-item">
    false && something (an expression)  is always false, and the part to the right of && operator is not tested.
    </li>
    <li class="collection-item">
    true || something (an expression) is evaluated to true, and the part to the right of the || operator is not tested.
    </li>
</ul>
Examples:
{% highlight javvascript linenos %}
var b = 5;
var c = 6;
 
if ((b === 5) || (b === 6))  { //the second part is never tested
    console.log('b is equal to 5 or equal to 6');
}
 
if ((b === 5) && (c === 6)) {  // second part is evaluated
    console.log('b  is equal to 5 and c is equal to 6');
}
 
if ((b === 15) && (c === 6)) {  // second part is never evaluated
    console.log('b  is equal to 5 and c is equal to 6');
} else {
    console.log('b not equal to 15 or c not equal to 6');
}
{% endhighlight %}
Implicit conversions of non boolean values in expressions

Used with logical operators or within statements, non-boolean values are implicitly converted to booleans.  

<strong class="red-text">All the following values are evaluated as false :</strong>
<ul class="collection">
    <li class="collection-item">false</li>
    <li class="collection-item">undefined</li>
    <li class="collection-item">null</li>
    <li class="collection-item">0</li>
    <li class="collection-item">NaN</li>
    <li class="collection-item">the empty string ''</li>
</ul>

<strong class="red-text">Everything else is evaluated as true!</strong>
{% highlight javascript linenos %}
var boo = 'hello' && 'world';
{% endhighlight %}
boo equals 'world' because 'hello' is a string value that is evaluated as true.
{% highlight javascript linenos %}
var boo2 = (0/0) || 43.2 ;
{% endhighlight %}
 boo2 equals 43.2 because the expression 0/0 equals NaN, which is evaluated as false.

__Question:__

What is the value of the variable myNumber after the execution of this code? 
{% highlight javascript linenos %}
var myNumber = !1;
 
if(myNumber == null){
   myNumber = 3;
}
 
myNumber = myNumber || 2;
{% endhighlight %}

__Explanation:__ after the first line, myNumber equals false. In the if statement, at line 3, false does not equal null. Therefore, the value 3 is not assigned to the var myNumber. In the last line, myNumber is evaluated as false, then the value 2 is given to the variable myNumber.

##### Comparison Operators
<ul class="collection">
    <li class="collection-item">Equal ==</li>
    <li class="collection-item">Not equal !=</li>
    <li class="collection-item">Greater than ></li>
    <li class="collection-item">Greater than or equal >=</li>
    <li class="collection-item">Less than <</li>
    <li class="collection-item">Less than or equal to <=</li>
    <li class="collection-item">Strict equal ===</li>
    <li class="collection-item">Strict not equal !==</li>
</ul>

What is the difference between __==__ and __===__ in JavaScript?

__Equal (==)__

Returns true if the operands are strictly equal with type conversion.

__Strict equal (===)__

Returns true if the operands are strictly equal with no type conversion.

The triple-equals operator never does type coercion. It returns true if both operands reference the same object, or in the case of value types, have the same value.

Some examples :
{% highlight javascript linenos %}
1 == 1 ;
//true
 
1 == 2 ;
//false
 
/* Here, the interpreter will try to convert the string ‘1’
into a number before doing the comparison */
 
1 == '1';
//true :
 
 
//with strict equal, no conversion:
 
1 === 1;
//true
1 === '1';
//false
{% endhighlight %}

<p class="materialize-red-text">
Depending on the context, generally strict equal (or strict not equal) is preferred. 
</p>
<p class="materialize-red-text">
Best practice for beginners: always use === or !== for comparisons.
</p>

Here's an interesting article about this question:

["Why you should use strict equal"](https://www.impressivewebs.com/why-use-triple-equals-javascipt/) (Impressive Webs, March 1st, 2012)

##### Specific case of NaN

As we have already seen, JavaScript has some special values. One of them is NaN: “Not-a-Number”. 

NaN has this special property : 
{% highlight javascript linenos %}
NaN == NaN;
// false
 
NaN === NaN;
// false
{% endhighlight %}

 __Nan is equal to nothing - not even to itself!__  But you do have a function to check the NaN value:  isNaN(expr) 

isNaN: returns true if the argument coerces to NaN, and otherwise returns false.
{% highlight javascript linenos %}
isNaN(NaN);
// true
 
isNaN(0/0);
// true
 
isNaN(12);
// false
 
isNaN('foo');
// true
{% endhighlight %}

"A reliable way for ECMAScript code to test if a value X is a NaN, is an expression of the form X !== X. The result will be true if, and only if, X is a NaN. " (see the [isNan documentation](http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.4)).

##### A complete example with isNaN: 
{% highlight javascript linenos %}
var num =0/0;
 
if(isNaN(num)){
   num = 0;
}
//shortened version with the conditional operator
var num = isNaN(num) ? 0 : num
 
//version with logical operator (implicit conversion)
var num = num || 0;
 
/*
   <=> num = NaN || 0
 
   <=> num = false || 0
*/
 
num;
//returns 0 in this three cases
{% endhighlight %}
Of course 0/0 rarely happens, but there are other cases where NaN can appear, for example:
<ul class="collection">
    <li class="collection-item">
    parseInt('foo');  returns NaN   //parseInt tries to convert a String to a Number    
    </li>
    <li class="collection-item">
    Math.sqrt(-1); return NaN     
    </li>
</ul>

-------

#### Conditional statements: if...then...else, switch
##### Conditional statements

__What are statements?__

JavaScript source code is a set of statements. There are a couple of different statement types. We have already seen one of them, the variable statement:
{% highlight javascript lineons %}
var myVar = 'hello ' + 'world';
{% endhighlight %}
We've also seen the expression statement:
{% highlight javascript linenos%}
3 + 4;
 
// more often like this
var x = (3 + 4);
var y = (5 + x);
{% endhighlight %}
A statement closes with a semicolon, but we will see later that missing semicolons are automatically inserted (for readability reasons, we highly recommend systematically adding a semicolon at the end of all statements).

Statements are generally executed sequentially from top to bottom of the script. However, this flow can be modified by statements such as conditional statements and iteration statements.

__The block statement__

The block statement is a simple statement which allows us to group a set of statements wrapped in curly braces. 

Block statement:
{% highlight javascript linenos %}
{
    var i = 0;
    var result = false;
    console.log('i = ' + i);
}
{% endhighlight %}
The block statement is used by other statements such as the if-statement or for-statement. We will see these statements below.

__Conditional statements__

All the examples for this section are in this codepen (to run it: click on the "edit on CodePen" label, and once in CodePen, open the devtool console to see the outputs of this program):

{% highlight javascript linenos %}
/*CONDITIONAL STATEMENTS*/
/*if statement*/

var num = 10;
if (num == 10) {
    num = 20;
}

console.log('if statement,\n num>> ' + num);

/*if-else statement*/

var num = 10;
if (num > 10) {
    num = 20;
} else {
    num = 0;
}

console.log('if-else statement,\n num>> ' +num);

/*
Question 1 
how to replace this code by an expression including one operator?
*/
var max; 
var min;
// Try to uncomment that and // see the difference!
// var min=1;
if (min){
    max = min + 10;
} else {
    max = 10;
}
console.log('question1, \n max>> ' + max);
//Answer is at the end of the document


/*switch statement*/

//this example is equivalent to the previous if-else example
var num = 10;
switch(num){
  case(num>10): num=20;
    break;
  default: num = 0;
}
console.log('switch1,\n num> ' + num);

//switch statement behaviour when break keyword is missing
//comment and uncomment cloudColor variable to see the different results

var gear = '';
//var cloudColor;
//var cloudColor = 'green';
var cloudColor = 'black';
switch(cloudColor) {
    case 'green': gear += 'spacesuit';
        break;
    case 'black': gear += 'boots, ';
    case 'grey': gear += 'umbrella, ';
    case 'white': gear += 'jacket, ';
    default: gear += 'watch';
}

console.log('switch2,\n gear >> ' + gear);

//The above example with break; 

var gear = '';
//var cloudColor;
//var cloudColor = 'green';
var cloudColor = 'black';
switch(cloudColor) {
    case 'green': 
      gear += 'spacesuit';
      break;
    case 'black': 
      gear += 'boots, ';
      break;
    case 'grey': 
      gear += 'umbrella, ';
      break;
    case 'white': 
      gear += 'jacket, ';
      break;
    default: 
      gear += 'watch';
}

console.log('swtich3,\n gear >> ' + gear);



/*
Question 1 
how to replace this code by an expression including one operator?
var max;
var min;
if (min){
    max = min + 10;
} else {
    max = 10;
}
*/

//Answer
var max;
var min;
max = (min)? min+10 : 10;
//console.log('question 1,\n max >> ' + max);
{% endhighlight %}
(Please look, edit and try whatever you want. There are parts that are commented - please remove comments and try to understand the results).

<p class="center">
Conditional statements are used to execute a unit of code 
</p>
<p class="center">
only if a condition is evaluated as true.
</p>

The if statement

Syntax:
{% highlight javascript linenos %}
if ( Expression ) Statement else Statement

if ( Expression ) Statement
{% endhighlight %}

__The expression may include:__

<ul class="collection">
    <li class="collection-item">
    logical operators ( ! && || )    
    </li>
    <li class="collection-item">
    comparison operators ( ==, ===, >, >=, <, <= )    
    </li>
    <li class="collection-item">
    any values or expressions which can be converted to boolean    
    </li>
</ul>

Example: if-statement
{% highlight javascript linenos %}
var num = 10;
 
if (num === 10) {
    num = 20;
}
 
// num equals 20
{% endhighlight %}

Example: if-else statement
{% highlight javascript linenos %}
var num = 10;
 
if (num > 10) {
    num = 20;
} else {
    num = 0;
}
 
// num equals 0
{% endhighlight %}

__Reminder:__

The following values will evaluate to false:
<ul class="collection">
    <li class="collection-item">false</li>
    <li class="collection-item">undefined</li>
    <li class="collection-item">null</li>
    <li class="collection-item">0</li>
    <li class="collection-item">NaN</li>
    <li class="collection-item">""(empty string)</li>
</ul>
<p class="materialize-red-text">
All other values, including all objects, evaluate to true when passed to a conditional statement.
</p>

__The if-then-else ternary operator__

This ternary operator is a shortcut version of if...then...else.

Let's look at this code example:
{% highlight javascript linenos %}
var max;
var min = 2;
 
if (min < 10) {
    max = min + 10;
} else {
    max = min;
}
{% endhighlight %}
__Explanation:__ You can replace this "if-then-else" statement with the ternary operator that uses a syntax with "?" and ":"
{% highlight javascript linenos %}
var max;
var min;
max = (min < 10)? min+10 : min;
{% endhighlight %}
Line 3 can be read as if (min < 10) then max = min+10, else max = min. The "then" part is after the "?" and the "else" part is after the ":" part.

This "short" version is not recommended except for very simple statements that involve a very obvious block of instructions for the "then" and the "else". Usually this syntax is much harder to read for beginners.

__Curly braces__

Should we use them in if-then-else statements? There are examples without curly braces on the Web: what does this mean?

Here are two versions of the same code.

Version 1: no curly braces
{% highlight javascript linenos %}
if (a > 2)
    result = 'a is bigger than 2';
else
    result = 'a is not bigger than 2';
{% endhighlight %}
Version 2: with curly braces for delimiting the "then" and "else" blocks
{% highlight javascript linenos %}
if (a > 2) {
    result = 'a is bigger than 2';
} else {
    result = 'a is not bigger than 2';
}
{% endhighlight %}
Version 1 and version 2 are equivalent. Indeed, version 1 is correct: you can omit curly braces if the "then" or "else" blocks are made of only one statement (one line of code).

But version 2 is cleaner and more readable, and, in particular, it is much better for maintainability (because you can add a statement just by pressing the enter key. And you can add some extra lines of code without worrying about adding curly braces because you broke the "1 line statement rule").

So it is strongly recommended that you always use if-statements 
enclosed in curly braces. 

Of course, one-line if-statements like this :
{% highlight javascript linenos %}
if (true) doSomething();
{% endhighlight %}
...are really fast to write, but if you want to add a second statement later it will become more time consuming.

__Conclusion:__ always use curly braces!

##### The switch statement

In order to avoid having a series of ifs and elses, it is possible to use a switch statement. 

The syntax of the switch statement is:
{% highlight javascript linenos %}
switch (expression) {
    case value1:
        statement
        break;       // break can be omitted in that case
                     // the second test case will be executed
                     // most of the time we add a break; at the end
                     // of a "case"
 
    case value2:
        statement
        break;
 
    case value3:
        statement
        break;
 
    default:         // if no case tested true
        statement
        break;
}
{% endhighlight %}
If the value of an expression equals one of the cases (the equality operator evaluated is ===), all the statements next to this case block are executed sequentially until the keyword break is reached.

Example 1: a common switch/case/default example.
{% highlight javascript linenos %}
var gear = '';
 
switch (cloudColor) {
    case 'green':
        gear = 'spacesuit';
        break;
 
    case 'black':
        gear = 'boots';
        break;
 
    case 'grey':
        gear = 'umbrella';
        break;
 
    case 'white':
        gear = 'jacket';
        break;
 
    default:
        gear = 'watch';
        break; // useless if in the last case
} // end of the switch statement
{% endhighlight %} 

In this example, if the clouds are grey, then my gear will be just an umbrella. If they are white, I'll wear only a jacket, if they are black I'll be nude with just boots (!), and if they are green I'll get a spacesuit. And if the cloud color is none of these, then I'll only wear a watch. The presence of the break keyword at the end of the different cases make the choices 100% exclusive. Only one case can be executed!

Example 2: a switch without "breaks" at the end of each case.
{% highlight javascript linenos %}
var gear = '';
 
switch (cloudColor) {
    case 'green':
        gear += 'spacesuit';
        break;
 
    case 'black':
        gear += 'boots, ';
 
    case 'grey':
        gear += 'umbrella, ';
 
    case 'white':
        gear += 'jacket, ';
 
    default:
        gear += 'watch';
} // end of the switch statement
{% endhighlight %} 
__Explanation:__ if the clouds are black, then my gear will be 'boots, umbrella, jacket, watch'. If the clouds are green, my gear is a spacesuit (because of the lack of the break keyword, other cases will not be tested). If the cloud color is not in the listed colors, then my gear is only a watch (default case).

To finish up this section, here is a complete example: three ways to do condition statements (to run it: click on the "edit on codepen" label and once in codepen, open the devtool console to see the outputs of this program):

{% highlight javascript linenos %}
/*CONDITIONAL STATEMENTS*/
/*3 examples which are equivalent*/

//try to change foo value 
var foo=1;
//var foo=2; 
//var foo=1000;
//var foo=0;
//var foo='1';

var bar1,bar2,bar3;

//example 1 
if(foo===1){
  bar1='one';
}
else if(foo===2){
  bar1='two';
}
else{
  bar1='something';
}

//example 2
bar2 = (foo===1)?'one':(foo===2)?'two':'something';

//example 3
switch(foo){
  case 1 :
    bar3='one';
    break;
  case 2 : 
    bar3 ='two';
    break;
  default:
    bar3 ='something';
}

//now we print results :

console.log('example1,\n bar1 >> ' + bar1);
console.log('example2,\n bar2 >> ' + bar2);
console.log('example3,\n bar3 >> ' + bar3);

{% endhighlight %}

-----------

#### Loop statements
##### Loops
A loop is used to run the same block of code several times while a condition is satisfied.

If you have trouble with loops, the online tool slowmoJS can be really useful: you just have to copy and paste an example into it to run it step by step and see how your program executes loops.

__The while statement__

With a while statement, a block of code is executed repeatedly while the specified condition is satisfied (evaluates to true).

Syntax:
{% highlight javascript linenos %}
while ( condition ) statement
{% endhighlight %}
The condition is an expression, and the statement can be a block statement.

Typical example of a while statement:
{% highlight javascript linenos %}
var i = 1, j = 1;
 
while ( i < 4 ) {
    j += i;
    i += 1; 
}
...
{% endhighlight %}

The block inside the while (lines 4 and 5) will be executed three times:
<ul class="collection">
    <li class="collection-item">
    Line 1 initializes i with a value of 1.    
    </li>
    <li class="collection-item">
    We enter the while statement at line 3. Is the value of i strictly less than 4?    
    </li>
    <li class="collection-item">
Yes, the variable i is equal to 1, we enter the statement inside the while.   
    </li>
    <li class="collection-item">
        Run 1:
        <ul class="collection">
            <li class="collection-item">
            We execute line 4: j += i; (equivalent to j = j + i). As j was set to 1 at line 1, j is now equal to 2.
            </li>
            <li class="collection-item">
            We execute line 5 and increment i by one. The variable i is now equal to 2.            
            </li>
            <li class="collection-item">
            We go back to the while at line 3. Is i < 4? Yes, we execute lines 3 and 4 again.
            </li>
        </ul>
    </li>
    <li class="collection-item">
        Run 2:
        <ul class="collection">
            <li class="collection-item">
            Now at the end of line 5, j is equal to "old j value" + "new i value", so j = 2 + 2 = 4, i has been incremented and is now equal to 3.
            </li>
            <li class="collection-item">
            We go back to the while at line 3. Is i < 4? Yes, we execute lines 3 and 4 again.
            </li>
        </ul>
    </li>
    <li class="collection-item">
        Run 3:
        <ul class="collection">
            <li class="collection-item">
            Now at the end of line 5, j is equal to "old j value" + "new i value", so j = 4 + 3 = 7, i has been incremented and is now equal to 4.
            </li>
            <li class="collection-item">
            We go back to the while at line 3. Is i < 4? No! The value of i is now 4, which is not less than 4. We continue the execution of the program at line 7 with i = 4 and j = 7.
            </li>
        </ul>
    </li>
</ul>

Of course, if the condition never evaluates to false, the block will be executed infinitely until the machine crashes... a test like while (i > 0) { .....} will never stop and will eat all the CPU.

Try this example now with slowmoJS !

__The do-while statement__

The do-while statement is very similar to the while statement, but its syntax is different:
{% highlight javascript linenos %}
do statement while ( condition )
{% endhighlight %}

Typical example:
{% highlight javascript linenos %}
var i = 0;
 
do {
    console.log('i = ' + i);
    i++;
} while(i < 20);
{% endhighlight %} 

console.log('Value of i after the do-while statement: ' + i);

The do-while statement executes the content of the loop once before checking the condition of the while, whereas a while statement will check the condition first before executing the content.

A do-while is used for a block of code that must be executed at least once.These situations tend to be relatively rare, thus the simple while-statement is more commonly used. 

If you want to "see" the difference, [look at the "do-while" statement with slowmoJS](http://toolness.github.io/slowmo-js/?code=var%20condition%3D%20false%3B%0Avar%20foo%20%3D%200%3B%0Ado%7B%0A%20foo%2B%2B%3B%0A%7D%20while(condition%20%3D%3D%20true)%3B%0A%0Afoo%3B&filterrange=80-80) and [the "while" statement slowmoJS](http://toolness.github.io/slowmo-js/?code=var%20condition%3D%20false%3B%0Avar%20foo%20%3D%200%3B%0Awhile(condition%20%3D%3D%20true)%3B%20%7B%0Afoo%2B%2B%0A%7D%0A%0Afoo%3B&filterrange=68-68). 

__The for statement__

This statement adds some things to the while and do-while statements: an initialization expression and an incrementing expression.

Its syntax is:
{% highlight javascript linenos %}
for (initialization; condition; incrementation) statement
{% endhighlight %}

The three expressions within the parentheses are optional. If the condition is omitted, it is replaced by true (infinite loop).

Typical example (counting from 0 to 10):
{% highlight javascript linenos %}
for (var i = 0; i <= 10; i++) {
   console.log('i = ' + i);
}
{% endhighlight %}

We can have more than one instruction in the "initialization part", and more than one instruction in the "incrementation part". Here is another example:

{% highlight javascript linenos %}
for (var i = 1, j = 1; i <= 10; i++, j+=2) {
    console.log('i = ' + i + ' j = ' + j);
}
{% endhighlight %}

In this example, two variables are defined and assigned within the initialization expression. Before each execution of the block statement, the condition is checked; here we need i <=10. After each execution of the block statement, the incrementation expression is executed to increment the variables i by 1 and j by 2.

Open the devtool console of your browser and copy and paste the above code, or [look at the slowmoJS execution](http://toolness.github.io/slowmo-js/?code=for%20(var%20i%20%3D%201%2C%20j%20%3D%201%3B%20i%20%3C%3D%2010%3B%20i%2B%2B%2C%20j%2B%3D2)%20%7B%0A%20%20%20%20console.log(%27i%20%3D%20%27%20%2B%20i%20%2B%20%27%20j%20%3D%20%27%20%2B%20j)%3B%0A%7D&filterrange=0-89).

__The for-in statement__

The for-in statement is used to iterate through an object (or through an array, which is also an object). 

Its syntax is:
{% highlight javascript linenos %}
for ( variable in expression ) statement
{% endhighlight %}
Typical example:
{% highlight javascript linenos %}
var michel = {              // michel is an object
    familyName:'Buffa',     // familyName, givenName, age
                            // are its properties
    givenName: 'Michel',
    age: 51
}
 
for(var property in michel) {   // the for-in will
                                // enumerate properties
    console.log(property);      // will print "familyName",
                                // "givenName",
                                // "age"
    console.log(michel[property]);  // michel['givenName'] same 
                                    // as michel.givenName
}
{% endhighlight %}

Before each execution of the block statement, the variable named "property" is assigned with the name of one of the properties (the keys) of the object.

We will see further examples of this statement in module 4, which is devoted to the study of JavaScript objects.

##### [ADVANCED] Other statements

__The continue statement__

The continue statement is used to stop the execution of a block and start the next iteration of the loop. The difference from the "break" statement is that the loop continues.

Syntax:

{% highlight javascript linenos %}
continue [label]
{% endhighlight %}
The label is optional.

Typical example:
{% highlight javascript linenos %}
for(var i = 1, k = 0; i < 5; i++) {
    if (i === 3) {
        continue;
    }
 
    k += 2*i;
    console.log('k += ' + (2*i));
}
console.log('Final k value:' + k)
{% endhighlight %}
Copy and paste this example in your devtool console, but first, try to guess what the value of k will be!

Hint: lines 2-4 mean that line 6 will never be executed for i = 3. That means that i*2 will only be added to k for i = 1, 2 and 4...

__The break statement__

The break statement is used to stop an iteration, a switch or a labelled statement.

Syntax:

{% highlight javascript linenos %}
break [label]
{% endhighlight %}
Typical example:
{% highlight javascript linenos %}
var tab = ['michel', 'john', 'donald', 'paul']; // johh at index = 1
 
function isNameInTheArray(name, theArray) {
    console.log("Number of elements in the array : " + theArray.length);
    for(var i=0; i < theArray.length; i++) {
        console.log('comparing with element in the array at pos ' + i);
 
        if(theArray[i] === name) {
           console.log('the name ' + name +
                       ' is in the array at pos: ' + i);
           break;
        } else {
           console.log(name + ' is not at pos ' + i);
        }
    }
}
 
// Execute the function
isNameInTheArray('john', tab);
{% endhighlight %}

Copy and paste in the devtool console. You'll see that the function that compares each element in the array passed as the second parameter with the name 'john', will stop looping after 'john' has been found at index = 1.

__Detailed explanations:__

<ul class="collection">
    <li class="collection-item">
    Line 20 executes the function    
    </li>
    <li class="collection-item">
    Line 6: The for statement loops on all existing indexes in the tab, from 0 to tab.length    
    </li>
    <li class="collection-item">
    Line 9: if the condition is true, we enter the block and execute lines 10-12    
    </li>
    <li class="collection-item">
    The break statement at line 12 will exit from the loop, it "breaks" the loop.    
    </li>
    <li class="collection-item">
    The different console.log(...) will never display the message "comparing with elements..." with indexes greater than 1: the loop exists when 'john' is found at index 1 (i equal to 1).   
    </li>
</ul>

------------

#### Functions and callbacks
#####Two ways to declare a function

__1 - Standard function declaration__

We've already seen that functions can be declared using this syntax:
{% highlight javascript linenos %}
function functionName(parameters) {
// code to be executed
}
{% endhighlight %}
A function declared this way can be called like this:
{% highlight javascript linenos %}
functionName(parameters);
{% endhighlight %}
Notice that we do not add a semicolon at the end of a function declaration. Semicolons are used to separate executable JavaScript statements, and a function declaration is not an executable statement.

Here is an example:
{% highlight javascript linenos %}
function sum(a, b) {
  // this function returns a result
  return (a + b);
}

function displayInPage(message, value) {
  // this function does not return anything
  document.body.innerHTML += message + value + "<br>";
}

var result = sum(3, 4);
displayInPage("Result: ", result);

// we could have written this
displayInPage("Result: ", sum(10, 15));
{% endhighlight %}

In the above example, the sum function returns a value, and the displayInPage function does not return anything.

__2 - Use a function expression__

A JavaScript function can also be defined using an expression that can be stored in a variable. Then, the variable can be used as a function:

Here is a typical example:
{% highlight javascript linenos %}
var sum = function(a, b) {
  return (a + b);
};

var displayInPage = function(message, value) {
  // this function does not return anything
  document.body.innerHTML += message + value + "<br>";
};

var result = sum(3, 4);
displayInPage("Result: ", result);

// we could have written this
displayInPage("Result: ", sum(10, 15));
{% endhighlight %}

Notice how the sum and displayInPage functions have been declared. We used a variable to store the function expression, then we can call the functions using the variable name. And we added a semicolon at the end, since we executed a JavaScript instruction, giving a value to a variable.

The "function expression" is an "anonymous function", a function without a name, that represents a value that can be assigned to a variable. Then, the variable can be used to execute the function.

We say that functions are "first class objects" which can be manipulated like any other object/value in JavaScript.

This means that functions can also be used as parameters to other functions. In this case they are called "callbacks".

##### Callbacks

Indeed, as functions are first-class objects, we can pass a function as an argument, as a parameter to another function and later execute that passed-in function or even return it to be executed later. When we do this, we talk about callback functions in JavaScript: a function passed to another function, and executed inside the function we called.

All the examples of event listeners that you've seen used callback functions. Here is another one that registers mouse click listeners on the window object (the window objects represent the whole HTML document):

{% highlight javascript linenos %}
// Add a click event listener on the whole document
// the processClick function is a callback:
// a function called by the browser when a click event
// is detected
window.addEventListener('click', processClick);

function processClick(event) {
  document.body.innerHTML += "Button clicked<br>";
}

// We could have written this, with the body of the callback as an argument of the addEventListener function
window.addEventListener('click', function(evt) {
  document.body.innerHTML += "Button clicked version 2<br>";
});
{% endhighlight %}

In this case, the processClick function is passed as a parameter to the addEventListener method/function.

Callback functions are derived from a programming paradigm known as functional programming. They are very, very common in JavaScript. We'll use them a lot in the next section of the course, called "Handling events".

-----------

### handling events
#### Introduction
Adding interactivity to a Web application can only be achieved with CSS, using the :hover pseudo CSS class, for instance. For example:
<div class="row">
    <div class="col s12 m6">
{% highlight javascript linenos %}
button:hover {
  color:red;
  border:2px solid;
}
{% endhighlight %}
    </div>
    <div class="col s12 m6">
<style type="text/css">
#hoverButton:hover {
  color:red;
  border:2px solid;
}
#box01 {
    border: 3px solid #000;
    height: 200px;
}
</style>
    <button id="hoverButton" class="btn">Put the mouse cursor over me</button>
    </div>

</div>

However, firing a specific action when the button is clicked, knowing which mouse button has been used, computing the (x, y) mouse pointer position in the button system coordinate, or executing more complex tasks can only be done through JavaScript.

With JavaScript, a button click, a move of the mouse, a resized window, and many other interactions create what are called "events".  The timing and order of events cannot be predicted in advance. We say that "event processing" is asynchronous. Web browsers detect events as they occur, and may pass them to JavaScript code. They do this by allowing you to register functions as event listeners, also called handlers or callbacks for specific events.

Each time an event occurs, the browser puts it in a "queue of events".

Then the browser looks at a list of "Event Listeners" and calls the ones that correspond to the type of event "they listen to".

#### Adding and removing event listeners
##### Event listeners: a typical example

Here is one possible syntax for registering an event listener that listens to "click" events on any part of the window (clicks anywhere on a web document will be processed by this event handler):
<div class="row">
    <div class="col s12 m6">
{% highlight javascript linenos %}
<script>
  addEventListener('click', function(evt) {
       document.body.innerHTML += "Button clicked!";
    });
</script>
{% endhighlight %}
    </div>
    <div id="box01" class="col s12 m6">
        <p>Click anywhere on this box</p>
    </div>
Try it below by clicking anywhere on the document:
<script>
  addEventListener('click', function(evt) {
      document.getElementById("box01").innerHTML += 'Button clicked!<br>';
  });
</script>
</div>

The addEventListener function is one possible syntax for registering a function to be called when a given type of event occurs.
{% highlight javascript linenos %}
addEventListener(type_of_elem, __callback_function__)
{% endhighlight %}

In the example below, the type of event is a 'click', and the callback function is the part in bold:

{% highlight javascript linenos %}
function(evt) {
   console.log("Button clicked!");
}t
{% endhighlight %}

When this function is small (a few lines of code), it's common practice to put its body as the second parameter of the addEventListener function.

In other words, this:

{% highlight javascript linenos %}
<script>
addEventListener('click', function(evt) {
    document.body.innerHTML += 'Button clicked!';
});
</script>
{% endhighlight %}
... is the same as this (the function called when a click occurs has its body "outside" of the addEventListener parameters, and we use its name as the second parameter):

{% highlight javascript linenos %}
<script>
addEventListener('click', processClick);
function processClick(evt) {
    console.log("Button clicked!");
}
</script>
{% endhighlight%}

Adding an event listener to specific HTML elements

Instead of listening to event on the whole document (using addEventListener is the same as using window.addEventListener), we can listen to specific DOM elements.

For example, here is how we can listen to clicks on a specific button (whereas clicks on the rest of the document will be ignored).
<div class="row">
    <div class="col s12 m8">
    {% highlight javascript linenos %}
<script>
    var b = document.querySelector("#myButton");
    b.addEventListener('click', function(evt) {
      alert("Button clicked");
    });
</script>    
    {% endhighlight %}
    </div>
    <div class="col s12 m4">
        <button id="myButton" class="btn">Click me!</button>
    </div>
 <script>
    var b = document.querySelector("#myButton");
    b.addEventListener('click', function(evt) {
      alert("Button clicked");
    });
</script>    
</div>

In this example, instead of using the addEventListener method directly, we used it on a DOM object (the button):
<ul class="collection">
    <li class="collection-item">
    1. Get a reference of the HTML element that can fire the events you want to detect. This is done using the DOM API that we'll cover in detail later this week. In this example we used one of the most common/useful methods: var b = document.querySelector("#myButton");
    </li>
    <li class="collection-item">
    2. Call the addEventListener method on this object. In the example: b.addEventListener('click', callback)
    </li>
</ul>

Every DOM object has an addEventListener method. Once you get a reference of  any HMTL element from JavaScript, you can start listening to events on it.

__An alternative method for adding an event listener to an HTML element: use an "on" attribute (ex: onclick = "....")__

Instead of using b.addEventListener('click', callback), it's possible to use an onclick='doSomething();' attribute directly in the HTML tag of the element:

<div class="row">
    <div class="col s12 m8">
    {% highlight javascript linenos %}
<button id="myButton2" class="btn" onclick="processClick(event);">Click me!</button>
<script>
   function processClick(evt) {
      alert("Button clicked");
   };
</script>
    {% endhighlight %}
    </div>
    <div class="col s12 m8">
        <button id="myButton2" class="btn" onclick="processClick(event);">Click me!</button>
    </div>
    <script>
        function processClick(evt) {
          alert("Button clicked");
        };
</script>     
</div>

This syntax:
{% highlight javascript linenos %}
<button id="myButton" onclick="processClick(event);">Click me!</button>
{% endhighlight %}
... is ok when you only need a single event listener to click events for this button, as there can be only one onclick attribute per element.

Using the b.addEventListener('click', callback) syntax,  you can register more than one event listener. You'll need rarely to do this, so in my opinion it's fine to choose whichever syntax you like.

Remember that for big projects, it's always better to separate the HTML, CSS and JavaScript code. In this case, I'd recommend that you put all your event listener definitions in a separate JavaScript file, and use the addEventListener syntax in preference to the "on" attributes syntax.

##### Removing event listeners
When we click on the button, we execute the processClick(evt) callback function, and inside we remove the listener we previously registered. Consequence: if we click on the button again, nothing happens as there is no longer a click event listener attached to it.

<div class="row">
    <div class="col s12 m8">
    {% highlight javascript linenos %}
<button id="myButton">Click me, this will work only once!</button>
  <p></p>
  <script>
    var b = document.querySelector("#myButton");
    b.addEventListener('click', processClick);
    
    function processClick(evt) {
     alert("Button clicked, event listener removed, try to click on the button again: nothing will happen anymore!"); 
      b.removeEventListener('click', processClick);
    }
  </script>     
    {% endhighlight %}
    </div>
    <div class="col s12 m8">
        <button id="myButton3"> class="btn" Click me, this will work only once!</button>
    </div>
      <script>
    var b = document.querySelector("#myButton3");
    b.addEventListener('click', processClick);
    
    function processClick(evt) {
     alert("Button clicked, event listener removed, try to click on the button again: nothing will happen anymore!"); 
      b.removeEventListener('click', processClick);
    }
  </script>
</div>

Note that to remove an event listener, you should have added it with its named function, so that we can pass it to both addEventListener and removeEventListener.

-------------

#### Event Object

##### The event object is the only parameter passed to event listeners
Typical example:
{% highlight javascript linenos %}
function processClick(evt) {
    alert("Button clicked!");
}
{% endhighlight %}

Each event listener has a single parameter that is  a "DOM event object". It has various properties and methods that can be very useful.

For example, with a 'keyup', 'keydown' or 'keypress' event, the event object contains the code of the key that has been pressed/released, with a 'mousemove' listener we can get the relative position of the mouse in the DOM element that has generated the event, etc.

The event object contains some important properties and methods that are common to all types of events:
<ul class="collection">
    <li class="collection-item">evt.type: the name of the event</li>
    <li class="collection-item">
    evt.target: for example, is the HTML element that has fired the event. In our previous examples with the click listeners on a button, evt.target in the event listener is the button itself.
    </li>
    <li class="collection-item">
    evt.stopPropagation(): will not propagate the event to all other elements that listen to it. If several elements are registered for a click event - for example, you have a click listener on a button and on the window (the whole page). If you click on the button, and if in its click event listener you call evt.stopPropagation(); then the click event listener on the window object will never be called.
    </li>
    <li class="collection-item">
    evt.preventDefault(): the default browser behavior will not be executed. For example, in a 'contextmenu' event listener attached to an object, if you call evt.preventDefault(), instead of having the right click default context menu of your browser displayed, you'll be able to display your own context menu, like in this example.
    </li>
</ul>

It also contains properties that are associated with the type of the event, for example:
<ul class="collectio">
    <li class="collection-item">
    evt.button: the mouse button that has been used in the case of a mouse event listener
    </li>
    <li class="collection-item">
    evt.keyCode: the code of the key that has been used
    </li>
    <li class="collection-item">
    evt.pageX: coordinate of the mouse relative to the page
    </li>
    <li class="collection-item">
    etc,
    </li>
</ul>

In the subsequent sections of this course we will look at the most common types of events in detail.

__Reference table__

The most useful common properties are:
<table class="bordered">
    <tr>
        <th>type</th>
        <td>Returns the name of the event.</td>
    </tr>
    <tr>
        <th>target</th>
        <td>Returns the element that triggered the event.</td>
    </tr>
</table>

The most useful common methods are:

<table class="bordered">
    <tr>
        <th>preventDefault()</th>
        <td>
        Cancels the event if it is "cancelable", meaning that the default action that belongs to the event will not occur. It is useful for cancelling the default browser behavior. For example: if you want to create a context menu that pops up with a right click, you must prevent the default behavior of the browser that will pop up its default context menu.    
        </td>
    </tr>
    <tr>
        <th>stopPropagation()</th>
        <td>Prevents further propagation of an event during event flow.</td>
    </tr>
</table>

-------

#### Page lifecycle events
These events detect when the page is loaded and when the DOM is ready.

##### Events related to the page lifecycle

There are many other events related to the page life cycle. The most useful ones for an introduction course are shown below:

<table class="bordered">
    <tr>
        <th>load</th>
        <td>
        This event occurs when an object has loaded (including all its resources: images, etc.). This event is very useful when you want to run JS code and be sure that the DOM is ready (in other words, be sure that a document.getElementById(...) or document.querySelector(...) will not raise an error because the document has not been loaded and elements you are looking for are not ready).
        </td>
    </tr>
    <tr>
        <th>resize</th>
        <td>
        The event occurs when the document view is resized. Usually, we get the new size of the window inside the event listener using var w = window.innerWidth; and
        var h = window.innerHeight;
        </td>
    </tr>
    <tr>
        <th>scroll</th>
        <td>
        The event occurs when an element's scrollbar is being scrolled. Usually in the scroll event listener we use things such as:
  var max = document.body.scrollHeight - innerHeight;
 var percent = (pageYOffset / max);
...to know the percentage of the scroll in the page.
        </td>
    </tr>
</table>

__Page event properties__

There are no particular properties that need to be mentioned here. Usually, the load event listener corresponds to a JavaScript function that can be seen as "the main" function of your Web application. It is a best practice to start everything after the page has been completely loaded. In the resize listener, you get the new size of the window, or the new size of some HTML elements in the page (as they might have been resized too when the window was resized), and then you do something (redraw a graphic in an HTML canvas that takes into account the new canvas size, for example).

Example 1: wait until the page is loaded (when the DOM is ready) before doing something

This first variant that uses <body onload="init();">